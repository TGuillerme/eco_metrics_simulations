---
title: "Simulating spaces and stressors"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---

This is a demo on how to simulate the spaces and apply the different stressors to reflect the mechanisms of interest.

# Simulating spaces

We can use the package `dads` that's in development for simulating the trait spaces (note that the package is still pretty unstable but the simple tasks here should not change).
Later, we can use the `dispRity::reduce.space` package to apply stressors to the data.

```{r, eval = FALSE}
library(devtools)
devtools::install_github("TGuillerme/dads")
devtools::install_github("TGuillerme/dispRity")
```

```{r}
library(dads)     # needs to be version >= 0.1.4
library(dispRity) # needs to be version >= 1.5.7
```

We will build simulate data using a Brownian Motion (the breath of trait values just increases with time, unconstrained), a pure birth tree (no extinction) and will stop the simulation as soon as we reach 200 taxa.
Note that I'll simulate a 2D Brownian Motion trait just for facilitating the visualisation of the stressors, however, for the paper we can stick to one dimension (one trait).

```{r, fig.height = 12, fig.width = 6}
## Creating the trait object (2D BM)
my_trait <- make.traits(process = BM.process, n = 2)

## Setting up the birth death parameters (no extinction)
bd_params <- list(speciation = 1)

## Setting up the stopping rules
stop_rule <- list(max.living = 200)

## Simulating the data
simulated_data <- dads(bd.params = bd_params,
                       stop.rule = stop_rule,
                       traits    = my_trait)

## We can then visualise the simulated data (just two show the process)
par(mfrow = c(2, 1))
plot(simulated_data, main = "The simulated BM through time")
plot(simulated_data, main = "The 2D BM", trait = c(1,2))

## The orange data points are node values and will be ignored
## Here we'll select only the tip values from the data
trait_space <- simulated_data$data[rownames(simulated_data$data) %in% simulated_data$tree$tip.label, ]
```

# Simulating the stressors

The stressors here are the processes we apply to change the normal pattern of the data (the BM motion generated normal distribution of the data) for simulating the different mechanisms.
To simulate these patterns, we can use the function `dispRity::reduce.space` that has already several algorithms implemented.
I'm happy to tweak/modify these algorithms (or create new ones!) to get results that better matches our needs.

For the stressors, we can unfortunately only remove species.
If we take the what-s-done-in-ecology approach this is not a big problem since this is what you'd expect anyways (i.e. your stressors can not "add" species, only make them go extinct).
So, although we've simulated 200 species, we're gonna resample 100 of them every time.

## Null mechanism

This is the really basic one: just a null model were we randomly sample 100 species out of the 200.
This can be done using the `stats::sample` function but for making the whole script neater, we can also use the `"random"` algorithm in `dispRity::reduce.space` that just randomly removes n% of species:

```{r}
## Removing 50% of the elements randomly
random_reduction <- reduce.space(trait_space,
                                 type = "random",
                                 remove = 0.5)
```

And we can visualise these results compared to the full distribution of 200 species:

```{r}
## Function for simplifying the plots
#' @param data the dataset
#' @param reduction the vector of selected element for the reduction
#' @param null the vector of selected element for the null
#' @param col two colours
#' @param pch the pch (default = 19)
#' @param trait which trait to plot (default is 1 for plot.1D and c(1,2) for plot.2D)
#' @param xlab the xlab
#' @param legend the legend text
plot.1D <- function(data, reduction, null, main, col = c("blue", "orange"), pch = 19, trait = 1, xlab = "trait values", legend) {
    ## Get the histograms
    main_plot <- hist(data, plot = FALSE)
    plot_1 <- hist(data[null, trait], plot = FALSE, breaks = main_plot$breaks)
    plot_2 <- hist(data[reduction, trait], plot = FALSE, breaks = main_plot$breaks)
    plot_height <- max(plot_1$counts, plot_2$counts)

    ## Make the colours as transparent (for overlaps)
    make.transparent <- function(col, alpha = 0.5) {
      rgb_vals <- grDevices::col2rgb(col)
      rgb_args <- list(red   = rgb_vals["red", ],
                       green = rgb_vals["green", ],
                       blue  = rgb_vals["blue", ],
                       maxColorValue = 255,
                       alpha = alpha * 255)
      return(do.call(grDevices::rgb, rgb_args))
    }
    ##Â Plot the histograms
    plot(plot_1, col = make.transparent(col[1]), ylim = c(0, plot_height),
        main = ifelse(missing(main), "", main),
        xlab = "Trait values", ylab = "Counts")
    plot(plot_2, col = make.transparent(col[2]), add = TRUE)

    ## Adding the legend
    if(!missing(legend)) {
        legend(x = "topleft", col = col, pch = pch, legend = legend)
    }
    ## Add the points
    points(x = data[null, trait], y = rep(0, sum(null)), col = "black", bg = col[1], pch = 21)
    points(x = data[reduction, trait], y = rep(-plot_height/50, sum(reduction)), col = "black", bg = col[2], pch = 21)
}
plot.2D <- function(data, reduction, null, main, col = c("blue", "orange"), pch= 19, trait = c(1,2), xlab = "trait values", legend) {
    ## Plotting the histogram
    plot(NULL, xlim = range(trait_space[, trait[1]]), ylim = range(trait_space[, trait[2]]), main = main)
    points(trait_space[null, trait], pch = pch, col = col[1])
    points(trait_space[reduction, trait], pch = pch, col = col[2])
    ## Adding the legend
    if(!missing(legend)) {
        legend(x = "topleft", col = col, pch = pch, legend = legend)
    }
}
```

```{r, fig.height = 12, fig.width = 6}
## Visualising the results
par(mfrow = c(2, 1))
plot.1D(trait_space, reduction = random_reduction, null = rep(TRUE, 200), main = "1D null mechanism", legend = c("Full distribution (200sp)", "Random reduction (100sp)"))
plot.2D(trait_space, reduction = random_reduction, null = !random_reduction, main = "2D null mechanism")
```


## Environmental filtering

For the environmental filtering algorithm, we can use the
We can use the `"position"` algorithm from the `dispRity::reduce.space` function that shifts the position of the group to one corner of the space so that X% of the data in on side and (1-X)% is on the other side (with side being weirder and weirder as dimensionality increases!):

```{r}
## Removing 50% to shift them
filtering_reduction <- reduce.space(trait_space,
                                    type = "position",
                                    remove = 0.5)
```

```{r, fig.height = 12, fig.width = 6}
## Visualising the results
par(mfrow = c(2, 1))
plot.1D(trait_space, reduction = filtering_reduction, null = random_reduction, main = "1D filtering mechanism")
plot.2D(trait_space, reduction = filtering_reduction, null = random_reduction, main = "2D filtering mechanism")
```

## Competitive exclusion

For simulating the competitive exclusion, we could use the `dispRity::reduce.space` `"evenness"` algorithm that basically "flattens" the curve (i.e. displacing things from the highest density regions to the sides).

```{r}
## Removing 50% to flatten the curve
competitive_exclusion <- reduce.space(trait_space,
                                    type = "evenness",
                                    remove = 0.5,
                                    parameters = list(power = 3))
```

```{r, fig.height = 12, fig.width = 6}

## Visualising the results
par(mfrow = c(2, 1))
plot.1D(trait_space, reduction = !competitive_exclusion, null = random_reduction, main = "1D excluding mechanism")
plot.2D(trait_space, reduction = !competitive_exclusion, null = random_reduction, main = "2D excluding mechanism")
```


## Equalising fitness processes

For simulating equalisation of fitness we can use the `"size"` algorithm from `dispRity::reduce.space`.
This removes elements around past a distance from the centre of the population (with the distance being determined automatically so that X% are inside the radius and 1-X% are outside):

```{r}
## Removing 50% to change the trait space size
equalizing_fitness <- reduce.space(trait_space,
                                    type = "size",
                                    remove = 0.5)
```

```{r, fig.height = 12, fig.width = 6}

## Visualising the results
par(mfrow = c(2, 1))
plot.1D(trait_space, reduction = equalizing_fitness, null = random_reduction, main = "1D equalising mechanism")
plot.2D(trait_space, reduction = equalizing_fitness, null = random_reduction, main = "2D equalising mechanism")
```

## Facilitation

This one might be a bit trickier (though doable).
One way to do it (as suggested in our last meeting) could be to simply add a number of data points to places that already have data. 
However, this will result in non-comparable number of elements in each simulations.

One alternative (at least for now) would be to use the `"density"` algorithm from `dispRity::reduce.space` that will reduce the nearest neighbours distance between elements (basically making clumps of two elements close to each other).

```{r}
## Removing 50% to change the trait space size
facilitation <- reduce.space(trait_space,
                             type = "density",
                             remove = 0.5)
```

```{r, fig.height = 12, fig.width = 6}
## Visualising the results
par(mfrow = c(2, 1))
plot.1D(trait_space, reduction = facilitation, null = random_reduction, main = "1D facilitation mechanism")
plot.2D(trait_space, reduction = facilitation, null = random_reduction, main = "2D facilitation mechanism")
```